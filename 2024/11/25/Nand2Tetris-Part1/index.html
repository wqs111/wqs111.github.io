<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Nand2Tetris_Part1 | RadiantFlame</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad: false});</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
  --theme-encrypt-confirm: '确认'
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Nand2Tetris_Part1</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2024-11-25T08:07:42.000Z" id="date"> 2024-11-25</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-11-25T08:14:53.419Z" id="updated"> 2024-11-25</time></div></span><br><span>文章总字数: <div class="control">4.3k</div></span><br><span>预计阅读时间: <div class="control">21 分钟</div></span></div></div><hr><div id="post-content"><p>mini版数电+计组+汇编，像搭积木一样了解计算机体系结构。</p>
<span id="more"></span>

<p>注意：<a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2024/pdf/40756445/1728970903014-1997bd51-4e90-4dba-ae44-7ed57540dd99.pdf">计算机系统要素 从零开始构建现代计算机 (（美）NOAM NISAN，SHIMON SCHOCKEN著) (Z-Library).pdf</a></p>
<p>官网给出的<a target="_blank" rel="noopener" href="https://www.nand2tetris.org/course">课程PPT</a>，补充了不少课本上没有的内容。</p>
<h1 id="Project-walkthrough"><a href="#Project-walkthrough" class="headerlink" title="Project  walkthrough"></a>Project  walkthrough</h1><p>接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs plain"> * Nand gate: Nand()<br> * if (a and b) out = 0, else out = 1 <br> --------------------------------------------------------<br> * Not gate: Not()<br> * if (in) out = 0, else out = 1<br><br>  * And gate: And()<br> * if (a and b) out = 1, else out = 0 <br><br>  * Or gate: Or()<br> * if (a or b) out = 1, else out = 0 <br><br> * Exclusive-or gate: Xor()<br> * if ((a and Not(b)) or (Not(a) and b)) out = 1, else out = 0<br>--------------------------------------------------------<br> * Multiplexor: Mux()<br> * if (sel = 0) out = a, else out = b<br><br> * Demultiplexor: DMux()<br> * [a, b] = [in, 0] if sel = 0<br> *          [0, in] if sel = 1<br>--------------------------------------------------------<br>  * 16-bit Not gate: Not16()  // And16 Or16 Mux16同理<br> * for i = 0, ..., 15:<br> * out[i] = Not(a[i])<br><br>  * 8-way Or gate: Or8Way()<br> * out = in[0] Or in[1] Or ... Or in[7]<br>--------------------------------------------------------<br>  * 4-way 16-bit multiplexor: Mux4Way16() // 8way 同理 Mux8Way16()<br> * out = a if sel = 00<br> *       b if sel = 01<br> *       c if sel = 10<br> *       d if sel = 11<br><br><br>  * 4-way demultiplexor: DMux4Way() // 8way 同理<br> * [a, b, c, d] = [in, 0, 0, 0] if sel = 00<br> *                [0, in, 0, 0] if sel = 01<br> *                [0, 0, in, 0] if sel = 10<br> *                [0, 0, 0, in] if sel = 11<br><br>--------------------------------------------------------<br>  * 16-bit adder: Add16()<br>  * Adds two 16-bit two&#x27;s complement values.<br> * The most significant carry bit is ignored.<br><br>  * 16-bit incrementer: Inc16()<br> * out = in + 1<br><br>--------------------------------------------------------<br> * ALU (Arithmetic Logic Unit):<br> * Computes out = one of the following functions:<br> *                0, 1, -1,<br> *                x, y, !x, !y, -x, -y,<br> *                x + 1, y + 1, x - 1, y - 1,<br> *                x + y, x - y, y - x,<br> *                x &amp; y, x | y<br> * on the 16-bit inputs x, y,<br> * according to the input bits zx, nx, zy, ny, f, no.<br> * In addition, computes the two output bits:<br> * if (out == 0) zr = 1, else zr = 0<br> * if (out &lt; 0)  ng = 1, else ng = 0<br> <br></code></pre></td></tr></table></figure>





<p>不难</p>
<p>值得一提的是 Mux 和 DMux 的设计：每位的0，1都会将输入值分为两半，两者的运算方向相反，每次都处理一半的输入，例如从16-&gt;8-&gt;4-&gt;2-&gt;1+1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs plain">// This file is part of www.nand2tetris.org<br>// and the book &quot;The Elements of Computing Systems&quot;<br>// by Nisan and Schocken, MIT Press.<br>// File name: projects/1/DMux8Way.hdl<br><br>/** <br> * Multiplexor:<br> * if (sel = 0) out = a, else out = b<br> */<br>CHIP Mux &#123;<br>    IN a, b, sel;<br>    OUT out;<br><br>    PARTS:<br>    //// Replace this comment with your code.<br>    //   sel and b or ~sel and a<br>    And(a= sel, b= b, out= ob);<br>    Not(in= sel, out= ns);<br>    And(a= ns, b= a, out= oa);<br>    Or(a= oa, b= ob, out= out);<br>&#125;<br><br><br>/**<br> * Multiplexor:<br> * if (sel = 0) out = a, else out = b<br> *<br> * Demultiplexor:<br> * [a, b] = [in, 0] if sel = 0<br> *          [0, in] if sel = 1<br> */<br>CHIP DMux &#123;<br>    IN in, sel;<br>    OUT a, b;<br><br>    PARTS:<br>    //  if ~sel then a = in<br>    //     else      b = in<br>    Not(in= sel, out= ns);<br>    Mux(a= in, b= false, sel= sel, out= a);<br>    Mux(a= in, b= false, sel= ns, out= b);<br>&#125;<br><br><br><br>/**<br> * 4-way 16-bit multiplexor:<br> * out = a if sel = 00<br> *       b if sel = 01<br> *       c if sel = 10<br> *       d if sel = 11<br> */<br>CHIP Mux4Way16 &#123;<br>    IN a[16], b[16], c[16], d[16], sel[2];<br>    OUT out[16];<br>    <br>    PARTS:<br>    //// Replace this comment with your code.<br>    //   sel[1] = 0 在a，b中选择;   sel[0] = 0  &gt;&gt; a<br>    Mux16(a= a, b= b, sel= sel[0], out= ab);<br>    Mux16(a= c, b= d, sel= sel[0], out= cd);<br>    Mux16(a= ab, b= cd, sel= sel[1], out= out); <br>&#125;<br><br><br><br><br>/**<br> * 4-way demultiplexor:<br> * [a, b, c, d] = [in, 0, 0, 0] if sel = 00<br> *                [0, in, 0, 0] if sel = 01<br> *                [0, 0, in, 0] if sel = 10<br> *                [0, 0, 0, in] if sel = 11<br> */<br>CHIP DMux4Way &#123;<br>    IN in, sel[2];<br>    OUT a, b, c, d;<br><br>    PARTS:<br>    //// Replace this comment with your code.<br>    //   DMux 实现了对a，b的分配 sel-&gt;a, ~sel-&gt;b<br>    DMux(in= in, sel= sel[1], a= ab, b= cd);<br>    DMux(in= ab, sel= sel[0], a= a, b= b);<br>    DMux(in= cd, sel= sel[0], a= c, b= d);<br>&#125;<br><br><br>/**<br> * 8-way demultiplexor:<br> * [a, b, c, d, e, f, g, h] = [in, 0,  0,  0,  0,  0,  0,  0] if sel = 000<br> *                            [0, in,  0,  0,  0,  0,  0,  0] if sel = 001<br> *                            [0,  0, in,  0,  0,  0,  0,  0] if sel = 010<br> *                            [0,  0,  0, in,  0,  0,  0,  0] if sel = 011<br> *                            [0,  0,  0,  0, in,  0,  0,  0] if sel = 100<br> *                            [0,  0,  0,  0,  0, in,  0,  0] if sel = 101<br> *                            [0,  0,  0,  0,  0,  0, in,  0] if sel = 110<br> *                            [0,  0,  0,  0,  0,  0,  0, in] if sel = 111<br> */<br>CHIP DMux8Way &#123;<br>    IN in, sel[3];<br>    OUT a, b, c, d, e, f, g, h;<br><br>    PARTS:<br>    //// Replace this comment with your code.<br>    //   对MUX的逆向<br>    DMux(in= in, sel= sel[2], a= abcd, b= efgh);<br>    DMux(in= abcd, sel= sel[1], a= ab, b= cd);<br>    DMux(in= efgh, sel= sel[1], a= ef, b= gh);<br>    DMux(in= ab, sel= sel[0], a= a, b= b);<br>    DMux(in= cd, sel= sel[0], a= c, b= d);   <br>    DMux(in= ef, sel= sel[0], a= e, b= f);<br>    DMux(in= gh, sel= sel[0], a= g, b= h);<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p>学东西就留下具体实践解决生活问题这才是技术之根本  。</p>
</blockquote>
<p>ALU 完成  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs plain">// This file is part of www.nand2tetris.org<br>// and the book &quot;The Elements of Computing Systems&quot;<br>// by Nisan and Schocken, MIT Press.<br>// File name: projects/2/ALU.hdl<br>/**<br> * ALU (Arithmetic Logic Unit):<br> * Computes out = one of the following functions:<br> *                0, 1, -1,<br> *                x, y, !x, !y, -x, -y,<br> *                x + 1, y + 1, x - 1, y - 1,<br> *                x + y, x - y, y - x,<br> *                x &amp; y, x | y<br> * on the 16-bit inputs x, y,<br> * according to the input bits zx, nx, zy, ny, f, no.<br> * In addition, computes the two output bits:<br> * if (out == 0) zr = 1, else zr = 0<br> * if (out &lt; 0)  ng = 1, else ng = 0<br> */<br>// Implementation: Manipulates the x and y inputs<br>// and operates on the resulting values, as follows:<br>// if (zx == 1) sets x = 0        // 16-bit constant<br>// if (nx == 1) sets x = !x       // bitwise not<br>// if (zy == 1) sets y = 0        // 16-bit constant<br>// if (ny == 1) sets y = !y       // bitwise not<br>// if (f == 1)  sets out = x + y  // integer 2&#x27;s complement addition<br>// if (f == 0)  sets out = x &amp; y  // bitwise and<br>// if (no == 1) sets out = !out   // bitwise not<br><br>CHIP ALU &#123;<br>    IN  <br>        x[16], y[16],  // 16-bit inputs        <br>        zx, // zero the x input?<br>        nx, // negate the x input?<br>        zy, // zero the y input?<br>        ny, // negate the y input?<br>        f,  // compute (out = x + y) or (out = x &amp; y)?<br>        no; // negate the out output?<br>    OUT <br>        out[16], // 16-bit output<br>        zr,      // if (out == 0) equals 1, else 0  零标记<br>        ng;      // if (out &lt; 0)  equals 1, else 0  负数标记<br><br>    PARTS:<br>    //// Replace this comment with your code.<br><br>    // x 经过标志位后可能为 x, 0, !x, !0<br>    Mux16(a= x, b= false, sel= zx, out= XorZero);<br>    Not16(in= XorZero, out= negateX);<br>    Mux16(a= XorZero, b= negateX, sel= nx, out= newX);<br>    Mux16(a= y, b= false, sel= zy, out= YorZero);<br>    Not16(in= YorZero, out= negateY);<br>    Mux16(a= YorZero, b= negateY, sel= ny, out= newY);<br><br>    // 完成 加法，与运算<br>    Add16(a = newX, b = newY, out = sum);<br>    And16(a= newX, b= newY, out= logic);<br><br>    Mux16(a= logic, b= sum, sel= f, out= dirOut);<br>    Not16(in= dirOut, out= NdirOut);<br><br>    // 输出 <br>    Mux16(a= dirOut, b= NdirOut, sel= no, out= out1);<br>    And16(a= out1, b= true, out[0..7]= olow, out[8..15]= ohigh);<br>    Or8Way(in= olow, out= lhas1);<br>    Or8Way(in= ohigh, out= hhas1);<br>    Or(a= lhas1, b= hhas1, out= has1);<br>    Not(in= has1, out= zr);<br><br>    And16(a= out1, b= true, out[15]= isneg);<br>    And(a= isneg, b= isneg, out= ng);<br><br>    And16(a= out1, b= true, out= out);<br><br><br><br>    /*<br>    //   处理 zx nx zy ny -&gt;  XorZero YorZero negateX negateY<br>    Mux16(a= x, b= false, sel= zx, out= XorZero);<br>    Not16(in= XorZero, out= negateX);<br>    Mux16(a= y, b= false, sel= zy, out= YorZero);<br>    Not16(in= YorZero, out= negateY);<br><br>    //    选择 x 或 zx 作为用于下一步运算<br>    Mux(a= x, b= XorZero, sel= zx, out= );<br><br><br>    //    处理 f 运算      -&gt;  xpy (x+y)  xay (x&amp;y)<br>    Add16(a = x, b = y, out = xpy);<br>    And16(a= x, b= y, out= xay); <br><br>        //    处理 out 结果 和 zr ng 标签   <br>    */<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>本ALU没有涉及时序逻辑中的shift功能。 </p>
<p>2024&#x2F;10&#x2F;16</p>
<h1 id="Project-3-时序逻辑"><a href="#Project-3-时序逻辑" class="headerlink" title="Project 3 时序逻辑"></a>Project 3 时序逻辑</h1><blockquote>
<p> It’s a poor sort of memory that only works backward. </p>
<p> 记忆如此悲怜，只能回溯过去。</p>
<p> —- Lewis Carroll (1832 ~ 1898 ) , 英国作家  </p>
</blockquote>
<p>接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">* 1-bit register: Bit()<br>* If load is asserted, the register&#x27;s value is set to in;<br>* Otherwise, the register maintains its current value:<br>* if (load(t)) out(t+1) = in(t), else out(t+1) = out(t)<br><br>* 16-bit register: Register()<br>* If load is asserted, the register&#x27;s value is set to in;<br>* Otherwise, the register maintains its current value:<br>* if (load(t)) out(t+1) = int(t), else out(t+1) = out(t)<br><br>* 8 Way 16-bits Memory: RAM8()<br></code></pre></td></tr></table></figure>





<p>还得绕一下，把输出接到输入，所有第一步其实在第二步的后面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">/**<br> * 1-bit register:<br> * If load is asserted, the register&#x27;s value is set to in;<br> * Otherwise, the register maintains its current value:<br> * if (load(t)) out(t+1) = in(t), else out(t+1) = out(t)<br> */<br>CHIP Bit &#123;<br>    IN in, load;<br>    OUT out;<br><br>    PARTS:<br>    //   注意有一个时钟t信号<br>    <br>    // 2. 选择写入新数据或旧数据<br>    Mux(a= old, b= in, sel= load, out= new);<br><br>    // 1. 输出接回到mux作待选择信号<br>    DFF(in= new, out= old, out = out);   <br>&#125;<br></code></pre></td></tr></table></figure>





<p>内存的设计也很巧妙，将load信号进行分配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 此处按照地址分配正确的load信号，接受到load的那一条路才会进行数据操作<br>DMux8Way(in= load, sel= address, a= l1, b= l2, c= l3, d= l4, e= l5,<br>						 f= l6, g= l7, h= l8);<br><br>Register(in= in, load= l1, out= r1);<br>Register(in= in, load= l2, out= r2);<br>Register(in= in, load= l3, out= r3);<br>Register(in= in, load= l4, out= r4);<br>Register(in= in, load= l5, out= r5);<br>Register(in= in, load= l6, out= r6);<br>Register(in= in, load= l7, out= r7);<br>Register(in= in, load= l8, out= r8);<br><br>Mux8Way16(a= r1, b= r2, c= r3, d= r4, e= r5, f= r6, g= r7, h= r8, <br>					sel= address, out= out);<br></code></pre></td></tr></table></figure>



<p>RAM64： 地址线高三位先选择某片内存，低三位在raw内选存储器</p>
<p>PC: 可以置零，加一，输入新值，频繁更改。注意标志位的处理顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">CHIP PC &#123;<br>    IN in[16], reset, load, inc;<br>    OUT out[16];<br>    <br>    PARTS:<br>    // 功能：置零，输入，保持，加一<br>    Inc16(in= old, out= Inc);<br>    Mux16(a= old, b= Inc, sel= inc, out= ifInc);<br>    Mux16(a= ifInc, b= in, sel= load, out= ifIn);<br>    Mux16(a= ifIn, b= false, sel= reset, out= fin);<br>    <br>    // 注意：load输入仅控制是否写入in[16]，不应影响reset,inc的写入<br>    Register(in= fin, load= true, out= old, out=out);<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>2024&#x2F;10&#x2F;19</p>
<h1 id="Project-4-汇编"><a href="#Project-4-汇编" class="headerlink" title="Project 4 汇编"></a>Project 4 汇编</h1><p>我写汇编？真的假的？</p>
<p>Before the porject…</p>
<blockquote>
<p><font style="color:rgb(51, 51, 51);">These files should be stored in your browser’s local storage by the web IDE.<br></font><font style="color:rgb(51, 51, 51);">这些文件应该通过Web IDE存储在浏览器的本地存储中。</font></p>
<p><font style="color:rgb(51, 51, 51);">Add.asm, Max.asm, Rect.asm, and Pong.asm should be in the Project 6 folder.</font><font style="color:rgb(51, 51, 51);"><br></font><font style="color:rgb(51, 51, 51);">Add.asm、Max.asm、Pong.asm和Pong.asm应位于Project 6文件夹中。</font></p>
<p><font style="color:rgb(51, 51, 51);">They can be accessed through the “Load file” button in either the CPU emulator or the assembler, as depicted here:</font><font style="color:rgb(51, 51, 51);"><br></font><font style="color:rgb(51, 51, 51);">它们可以通过CPU模拟器或汇编器中的“加载文件”按钮访问，如下所示：</font></p>
<p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2024/png/40756445/1729403024269-f4a29735-0ea1-42ed-ab6f-e3cce50fa46a.png'><img src="https://cdn.nlark.com/yuque/0/2024/png/40756445/1729403024269-f4a29735-0ea1-42ed-ab6f-e3cce50fa46a.png"></p>
<p><font style="color:rgb(51, 51, 51);">If you don’t see the folders for projects 4 and 6 in there, please try resetting your files (Settings &gt; Reset) and let me know if this fixes the issue.<br></font><font style="color:rgb(51, 51, 51);">如果你没有在那里看到项目4和6的文件夹，请尝试重置你的文件（设置 &gt; 重置），并让我知道这是否解决了问题。</font></p>
<p><font style="color:rgb(51, 51, 51);">(Note that this will clear the browser’s local storage, deleting your saved files, so make sure you back everything up before doing that!)<br></font><font style="color:rgb(51, 51, 51);">(Note这将清除浏览器的本地存储，删除您保存的文件，所以请确保您备份一切之前这样做！）</font></p>
</blockquote>
<p>来自：<a target="_blank" rel="noopener" href="https://www.coursera.org/learn/build-a-computer/discussions/forums/aHOgTSj3Eea7jBLLHPwd0w/threads/MhvG1icHEe-eowr_8CWnUw">从第一原理构建现代计算机：从 Nand 到俄罗斯方块（以项目为中心的课程） - 讨论 | Coursera</a></p>
<p>从这一章开始该仔细读project文档了，<a target="_blank" rel="noopener" href="https://www.yuque.com/qiuts/uctylv/bwpd21h8ws9x9pkd">项目 4：机器语言</a>。</p>
<p>在开始汇编之前，文档推荐先去proj6文件夹下感受一下汇编代码，给出了几个示例文件：加法，求max，经典弹球游戏之类的。将文件load进汇编器里，然后translate all将汇编转为机器码，完成后在binary code板块将其加载到cpu模拟器中运行。</p>
<p>注意：如果你编写的汇编代码需要使用目的地 DM&#x3D;… 或 ADM&#x3D;…，请改用 MD&#x3D;… 或 AMD&#x3D;…。</p>
<p>Hack 语言是区分大小写的。</p>
<p>另一个常见错误是在编写指令时使用小写字母或空格。例如，m&#x3D;1 或 M &#x3D; 1 都会导致语法错误。正确的语法是 <code>M=1</code>。</p>
<p>最佳实践：</p>
<blockquote>
<ul>
<li>使用大写字母为标签，如 LOOP，使用小写字母为变量，如 sum。</li>
<li>缩进你的代码：将所有不是标签声明的行向右缩进几个字符。</li>
<li>根据需要编写注释，以使你的代码清晰。</li>
<li>查看讲座或书籍中的程序，并遵循它们的示例。</li>
<li>像往常一样，努力编写优雅、高效且自解释的程序。</li>
</ul>
</blockquote>
<p>简单理解一下：Hacker计算机内部有A，D(a.k.a. address data)两个寄存器和可按地址访问的内存M[address]。将数或地址写入A寄存器的语法为<code>@value</code>,与M配合使用可进行访存，也可当作存储数字的寄存器使用，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">@5	// A = 5， echo A 输出 5<br>D=A // D = 5<br><br>@i  // 不存在于预设的名称将在内存中为其划分一块存储空间，命名为 i<br>    // 此时寄存器A内存储i所在的地址<br>M=6 // 此时相当于访问内存中为5的数据(Memory[5])，并存入数字 5 <br>D=M // 将Memory[5]的值放入D寄存器，此时 echo D 输出 6<br></code></pre></td></tr></table></figure>



<p>闹麻了，卡了好几天了，让我看看怎么个事：</p>
<p>分析一下给出的汇编代码：主要是跳转指令有些模糊，使用了标志作为语法糖辅助跳转，思想与C中的goto一致，避免调用JMP指令时还需要程序员数行号进行跳转。跳转语句结构形如<code>D;JMP</code>，D为放入ALU计算的值，JMP指令根据ALU计算后的返回值按需跳转。</p>
<p>标志的结构为 <code>(SYMBOL)</code>括号括助，内部一般使用全大写表示，JMP语句调用前使用<code>@SYMBOL</code>将标志地址导入A寄存器，跳转语句将跳转至A寄存器所指的指令位置（行号）</p>
<p>完成后的程序需要将其卡住在程序的底部，防止PC增长，越界执行非法代码。</p>
<p>部分代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain">/*<br>    int i = 0;<br>    int R2 = 0;<br>    while (i &gt; 0) &#123;<br>        R2 += R0;<br>        i--;<br>    &#125;<br>*/<br><br>(LOOP)<br>    // if i == 0 end the loop and go out<br>    @i<br>    D=M<br>    @NEXT<br>    D;JLE<br>    // else i &gt; 0 then sum += R0, i -= 1<br>    @sum<br>    D=M  // D[sum]<br>    @R0<br>    D=D+M  // sum += R0<br>    @sum   <br>    M=D    // 将计算结果从内存的sum处写入R2处<br>    @i<br>    M=M-1  // i -= 1<br>    <br><br>    @LOOP<br>    0;JMP  // back to loop<br><br>(NEXT)<br>    @sum<br>    D=M<br>    @R2<br>    M=D  // 将sum的值存进R2<br><br>(END)<br>    // 无条件跳转，将程序控制在程序的最底部<br>    @END<br>    0;JMP<br></code></pre></td></tr></table></figure>



<p>IO部分更为有趣，从print到屏幕上对应hello world的像素亮起中间到底发生了什么，我很好奇。其实没有什么难的，内存中除了保存数据的部分，也有专门划分的用于保存显示器每个像素颜色的区域，调整这一小块内存的值就能改变对应像素的颜色，键盘输入也有一个专门的地址保存，CPU按需读取。</p>
<p>下一章将完成从CPU到computer的实现，激动人心。</p>
<h1 id="Project-5-计算机体系结构"><a href="#Project-5-计算机体系结构" class="headerlink" title="Project 5 计算机体系结构"></a>Project 5 计算机体系结构</h1><p>已给接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">A/DRegister(in[16], load, out[16])<br>ALU(x[16],y[16],zerox,negtivex,zy,ny,func,negout, out[16],if0,ifneg)<br>ROM32K(in:address[15], out[16])<br>PC(in[16],ifreset,ifload,ifInc,out[16])<br></code></pre></td></tr></table></figure>



<p>主要目标是完成CPU的设计，考虑到复杂性，已经给出大致设计:</p>
<p>指令或上一步输出经选择存入A寄存器，分两支处理</p>
<p>1 指令存入A寄存器 </p>
<p>A指令：[0 value*15]</p>
<p>C指令：[111 acccccc ddd jjj]分别按指令位执行计算，存入目的地，是否跳转 。 a-位域决定ALU是把A寄存器的输入当作操作数，还是把内存单元的输入当作 操作数  </p>
<p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2024/png/40756445/1730126275348-a8cd297b-d7bb-4601-80cb-042bb2e2952d.png'><img src="https://cdn.nlark.com/yuque/0/2024/png/40756445/1730126275348-a8cd297b-d7bb-4601-80cb-042bb2e2952d.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/40756445/1730126352099-41c9c6a7-46b1-490b-87ad-32111ddf4c35.png" alt="可见d1决定是否写入A寄存器，d2决定D，d3决定M"></p>
<p>由下图可见，c是ALU的参数，d和j需要单独处理，图中未标出。</p>
<p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2024/png/40756445/1730127076043-fb8cfb49-bae1-4227-b6fa-ebb87c2b98b7.png'><img src="https://cdn.nlark.com/yuque/0/2024/png/40756445/1730127076043-fb8cfb49-bae1-4227-b6fa-ebb87c2b98b7.png" alt="注意到指令中不同位与图中控制位的颜色有对应关系"></p>
<p>把流程理一下：指令内存传入指令instruction，Memory out端传入inM信号，通过ins[15]的值判断Areg存入指令还是上次计算的结果。c指令，接下来将ALU标志位传入ALU，d位分别传入A，Dreg和最终输出位writeM决定是否写入A，D，M中。然后是j位是跳转条件，根据ALU两个输入之差的正负判断大于小于情况，与JMP要求相符则同意PC的下一时刻的值为Areg中的目标地址。否则PC自律（自增，重置…）。最终CPU输出out写入内存中（如果d位同意的话）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">// C指令必须是1开头  [ixx acccccc ddd jjj]<br>//    index:         FED CBA9876 543 210<br></code></pre></td></tr></table></figure>

<p>a位域0表示将A reg作为数值计算，1表示作为内存读取</p>
<p>以汇编代码<code>@5 D=A</code>为例解析：</p>
<p>A指令传入，Mux选择指令写入Areg，A指令结束。</p>
<p>C指令从Areg与inM中选择Areg的值传入ALU，不进行计算直接输出，途径load态Dreg将数值写入，跳转码为000，不执行。Areg，Memory为非load态，不写入数据。C指令结束。</p>
<p>还需处理JMP指令，通过ALU的输出进行判断大于小于条件是否成立，作为PC的load条件，in为A reg的值，当load成立，则PC转入A指向的值；否则PC正常自增。</p>
<p>注意：ALU及其他c位域必须在c指令时才生效（And检验instruction[15] &amp; instruction[c]）</p>
<p>至此CPU的运行逻辑就很清晰了，务必自行设计汇编案例通过人脑模拟CPU。</p>
<p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2024/png/40756445/1730269016935-eb74faf1-73d4-4988-b853-2f84819772f6.png'><img src="https://cdn.nlark.com/yuque/0/2024/png/40756445/1730269016935-eb74faf1-73d4-4988-b853-2f84819772f6.png"></p>
<p>来自<a target="_blank" rel="noopener" href="https://github.com/fkgkdfgy/from_nand_2_tetris/blob/master/projects/05/CPU.hdl">fkgkdfgy</a>的HDL代码，太优雅了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plain">PARTS:<br>// Put your code here:<br>// A Register pipeline<br>Mux16(a=instruction,b=outALU,sel=instruction[15],out=inA);<br>And(a=instruction[15],b=instruction[5],out=insCloadA);<br>Not(in=instruction[15],out=insAloadA);<br>Or(a=insAloadA,b=insCloadA,out=loadA);<br>Register(in=inA,load=loadA,out=outA,out[0..14]=addressM);<br>Mux16(a=outA,b=inM,sel=instruction[12],out=outAorM);<br><br>// D Register pipeline<br>And(a=instruction[15],b=instruction[4],out=loadD);<br>Register(in=outALU,load=loadD,out=outD);<br><br>// PC pipeline<br>Or(a=outzr,b=outng,out=interresult);<br>Not(in=interresult,out=pos);<br>And(a=instruction[2],b=outng,out=statNg);<br>And(a=instruction[1],b=outzr,out=statZero);<br>And(a=instruction[0],b=pos,out=statPos);<br>Or(a=statNg,b=statPos,out=statInter1);<br>Or(a=statInter1,b=statZero,out=statInter2);<br>And(a=statInter2,b=instruction[15],out=loadPC);<br><br>Or(a=loadPC,b=reset,out=notinc);<br>Not(in=notinc,out=incPC);<br>PC(in=outA,<br>   inc=incPC,load=loadPC,reset=reset,<br>   out[0..14]=pc);<br><br>// ALU pipeline<br>ALU(x=outD,y=outAorM,<br>    zx=instruction[11],nx=instruction[10],<br>    zy=instruction[9],ny=instruction[8],<br>    f=instruction[7],no=instruction[6],<br>    out=outALU,zr=outzr,ng=outng,<br>    out=outM);<br>And(a=instruction[15],b=instruction[3],out=writeM);<br></code></pre></td></tr></table></figure>



<p>Computer</p>
<p>汇编代码烧录到ROM指令内存后由ROM和CPU交互，接受PC的地址，将对应地址的指令传入CPU。计算过程与数据内存进行读写。</p>
<p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2024/png/40756445/1730270817695-a5b55a8b-eac1-425c-b73f-8a19e3c91ecf.png'><img src="https://cdn.nlark.com/yuque/0/2024/png/40756445/1730270817695-a5b55a8b-eac1-425c-b73f-8a19e3c91ecf.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">CHIP Computer &#123;<br><br>    IN reset;<br><br>    PARTS:<br>    //// Replace this comment with your code.<br>    CPU(inM= fromMtoCPU, instruction= newInstruction, reset= reset, outM= CPUout, <br>        writeM= writeEnable, addressM= CPUwriteInMemory, pc= askForNewInstruction);<br>    <br>    ROM32K(address= askForNewInstruction, out= newInstruction);<br><br>    Memory(in= CPUout, load= writeEnable, address= CPUwriteInMemory, out= fromMtoCPU);<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码稍微有一点点绕，把输出变量名写清晰就好多了。</p>
<p>接下来的软件部分后续可能会抽时间慢慢做，先啃OS去了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/641519445">Nand2Tetris 通关感想 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/snowsteps/p/18172637">nand2tetris_hack计算机 - 柠檬水请加冰 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/fkgkdfgy/from_nand_2_tetris/tree/master">GitHub - fkgkdfgy&#x2F;from_nand_2_tetris</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/10/24/%E4%BA%92%E8%81%94%E7%BD%91%E6%96%87%E6%91%982024-10/">互联网文摘2024-10 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Quits Wang</a></h1><div id="description"><p>Die Luft der Freiheit weht.</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/wqs111"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="mailto:wqs820626@gmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/107678025"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Project-walkthrough"><span class="toc-number">1.</span> <span class="toc-text">Project  walkthrough</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Project-3-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="toc-number">2.</span> <span class="toc-text">Project 3 时序逻辑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Project-4-%E6%B1%87%E7%BC%96"><span class="toc-number">3.</span> <span class="toc-text">Project 4 汇编</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Project-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">Project 5 计算机体系结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><footer><nobr><span class="icp-title">copyright</span><a class="icp-content" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/lib/encrypt/hbe.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>