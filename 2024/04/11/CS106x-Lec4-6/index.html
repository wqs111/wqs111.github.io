<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>CS106x-Lec4~6 | RadiantFlame</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad: false});</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
  --theme-encrypt-confirm: 'confirm'
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>CS106x-Lec4~6</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-04-11T13:52:10.000Z" id="date"> 2024-04-11</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-04-11T13:54:42.676Z" id="updated"> 2024-04-11</time></div></span><br><span>Word Count: <div class="control">6.2k</div></span><br><span>Read Time: <div class="control">27 min</div></span></div></div><hr><div id="post-content"><p>好有意思的作业，但是抽象也是真的抽象。</p>
<span id="more"></span>

<h1 id="word-Ladder-广度优先搜索"><a href="#word-Ladder-广度优先搜索" class="headerlink" title="word-Ladder 广度优先搜索"></a>word-Ladder 广度优先搜索</h1><p>利用广度优先搜索实现在字典中查找单词使起点词到终点词每次只变动一个字母<br />读源码发现只需完成 generateLadder 函数，传入参数 Lexicon 型 字典常量 english， 起点词与终点词</p>
<p>关于 Lexicon 型变量：<br />和 Set 型变量有相同的函数接口，</p>
<p>围绕第 0 号找一圈，没有目标，出队，标记已访问；周围一圈每一号再重复，没找到；第二圈再重复，找到，输出每层相连的单词</p>
<p>首先构造函数找到与第 n 个词相似的词，即只有一个字母只差的词。<br />怎么找？<br />读 Reader 发现的一种遍历方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string word = <span class="string">&#x27;xx&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c0 = <span class="string">&#x27;a&#x27;</span>; c0 &lt;= <span class="string">&#x27;z&#x27;</span>; c0++)&#123;</span><br><span class="line">    word[<span class="number">0</span>] = c0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>; c1 &lt;= <span class="string">&#x27;z&#x27;</span>; c1++)&#123;</span><br><span class="line">        word[<span class="number">1</span>] = c1;</span><br><span class="line">        <span class="keyword">if</span> (english.<span class="built_in">contains</span>(word)&#123;</span><br><span class="line">            cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (string word : english)&#123;</span><br><span class="line">    <span class="keyword">if</span> (word.<span class="built_in">length</span>() == <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写最小测试项目的邻居识别的时候注意到源码中全使用了静态变量，函数，遂查：</p>
<blockquote>
<p>static 不导出外部符号，如果你不准备在别的编译单元用，加上 static 就不需要命名得又臭又长来防止冲突了</p>
</blockquote>
<p>因为本次作业含 3 个小作业，所以使用静态定义就很方便。</p>
<p>继续找邻居，假设目标是 con -&gt; cot -&gt; bot<br />~~依次替换第一位为 26 个字母，第二位第三位同理，就有 26~~~~3~~~~ 种情况（！） ~~</p>
<p>屁嘞，不要这样干。遍历字典找和待检测 word 头一致<br />写了个单词变体，但是调试时发现会漏类型，从 aaa 开始，第一列变量 26 个字母，然后开始遍历第二列，但此时第一列静止了，或许应该单独开一个函数来处理此需求.</p>
<p>暂时不考虑此问题，完成一次入队后，调用该函数自身，传入字典，队首单词，终点单词.</p>
<p>开始修改上述问题:循环结束不更新 【高亮块】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//backup</span></span><br><span class="line"><span class="comment">//生成所有单词变体，若字典中有其变体，即加入队列并放入以访问集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> j = <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++)&#123;</span><br><span class="line">                word[i] = j;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;try: &quot; &lt;&lt; word &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (test.contains(word) &amp;&amp; !visited.contains(word))&#123;</span><br><span class="line">                    q.enqueue(word);</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; enqueue!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    visited.add(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>emmmmm……wait a minute</strong> 【加粗】</p>
<p>当前词的所有变体好像只需要找有一个字母之差的就 ok 了，我还闷头想怎么从“<code>aaa</code>”遍历到“<code>zzz</code>”，甚至想出来一个”<code>26进制的变形方法</code>“ 【内联代码】<br />差点算了整整$26 * 26 * 26 &#x3D; 26^3$【数学公式】</p>
<blockquote>
<pre><code>    //生成当前访问词的所有变体 搞不好是递归 将字符串看作是26进制的加法，每次将尾+1个ASCII值，到“z”进位
    //问题：如何判断进位循环语句要执行多少次 当位数&lt;strlen时 【引用】
</code></pre>
</blockquote>
<p><del>全体目光向我看齐！</del>【删除线】</p>
<p>然后开始改，不小心忘记引用传递，传进去要变化的结果定义成 const 型，debug 又发现似乎不能调用自身。</p>
<p>想了想，大概是搜索所有的邻居并入队，头出队；每个邻居依次搜索邻居并入队，头出队。</p>
<p>芜湖！！完成</p>
<p>源代码 【二级标题】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File: word-ladder.cpp</span></span><br><span class="line"><span class="comment"> * ---------------------</span></span><br><span class="line"><span class="comment"> * Implements a program to find word ladders connecting pairs of words.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lexicon.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;strlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="built_in">string</span> <span class="title function_">getWord</span><span class="params">(<span class="type">const</span> Lexicon&amp; english, <span class="type">const</span> <span class="built_in">string</span>&amp; prompt)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">string</span> response = trim(toLowerCase(getLine(prompt)));</span><br><span class="line">        <span class="keyword">if</span> (response.empty() || english.contains(response)) <span class="keyword">return</span> response;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Your response needs to be an English word, so please try again.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief traval</span></span><br><span class="line"><span class="comment"> * @param word</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * 查找邻居:查找当前词的所有变体，每次只变一个字母</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">travalCheck</span><span class="params">(<span class="type">const</span> Lexicon&amp; english, Set&lt;<span class="built_in">string</span>&gt;&amp; visited, Queue&lt;<span class="built_in">string</span>&gt;&amp; q, <span class="built_in">string</span>&amp; word)</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> temp = word;</span><br><span class="line">    <span class="type">int</span> length = word.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; length; n++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++)&#123;</span><br><span class="line">            word[n] = i;</span><br><span class="line">            <span class="keyword">if</span> (english.contains(word) &amp;&amp; !visited.contains(word))&#123;</span><br><span class="line">                q.enqueue(word);</span><br><span class="line">                visited.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        word[n] = temp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">generateLadder</span><span class="params">(<span class="type">const</span> Lexicon&amp; english, <span class="type">const</span> <span class="built_in">string</span>&amp; start, <span class="type">const</span> <span class="built_in">string</span>&amp; end)</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here&#x27;s where you&#x27;ll search for a word ladder connecting \&quot;&quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;\&quot; to \&quot;&quot;</span> &lt;&lt; end &lt;&lt; <span class="string">&quot;\&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BFS</span></span><br><span class="line"><span class="comment">     * TODO 读取start的邻居 con -&gt; cot/kon/ton</span></span><br><span class="line"><span class="comment">     * 先找第一个字母不同的邻居,找到的全放进Set存储</span></span><br><span class="line"><span class="comment">     * 邻居next 先赋start值，循环的改变，有和字典对上就放Set里，直到字典遍历完</span></span><br><span class="line"><span class="comment">     * 没找到目标，上回合的元素出队，next全入队，重复</span></span><br><span class="line"><span class="comment">     * 读取过的邻居设置为已访问-放进Set里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 先设置一个小字典进行测试</span></span><br><span class="line"><span class="comment">     * 先在while里面写好在模块化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Lexicon test = &#123;<span class="string">&quot;con&quot;</span>, <span class="string">&quot;cot&quot;</span>, <span class="string">&quot;bot&quot;</span>, <span class="string">&quot;bat&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;pit&quot;</span>, <span class="string">&quot;big&quot;</span>, <span class="string">&quot;dig&quot;</span>&#125;;</span><br><span class="line">    Set&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.enqueue(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; start &lt;&lt; &quot; enqueue &quot;&lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> word = q.peek();</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == end)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; q.peek() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Finally finished！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成相邻词并检验入队</span></span><br><span class="line">        travalCheck(test, visited, q, word);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成一次查找邻居后将第一位出队，避免死循环</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.dequeue() &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (!q.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cout all visited value</span></span><br><span class="line"><span class="comment">    for (string find : visited)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; find &lt;&lt; &quot; visited!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="built_in">string</span> kEnglishLanguageDatafile = <span class="string">&quot;res/dictionary.txt&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">playWordLadder</span><span class="params">()</span> &#123;</span><br><span class="line">    Lexicon <span class="title function_">english</span><span class="params">(kEnglishLanguageDatafile)</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">string</span> start = getWord(english, <span class="string">&quot;Please enter the source word [return to quit]: &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (start.empty()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">string</span> end = getWord(english, <span class="string">&quot;Please enter the destination word [return to quit]: &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (end.empty()) <span class="keyword">break</span>;</span><br><span class="line">        generateLadder(english, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Welcome to the CS106 word ladder application!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    playWordLadder();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thanks for playing!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    getLine(<span class="string">&quot;press [entre] to qiut.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你先别急，只是完成测试而已，把 test 字典换成 English 进行压力测试，测完发现有点弱智，al -&gt; ak -&gt; at 有冗余行为</p>
<p>继续！读档案发现了新的方法，队列里存的是数组而不是单词！<br />推倒重写逻辑部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">generateLadder</span><span class="params">(<span class="type">const</span> Lexicon&amp; english, <span class="type">const</span> <span class="built_in">string</span>&amp; start, <span class="type">const</span> <span class="built_in">string</span>&amp; end)</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here&#x27;s where you&#x27;ll search for a word ladder connecting \&quot;&quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;\&quot; to \&quot;&quot;</span> &lt;&lt; end &lt;&lt; <span class="string">&quot;\&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BFS</span></span><br><span class="line"><span class="comment">     * TODO 读取start的邻居 con -&gt; cot/kon/ton</span></span><br><span class="line"><span class="comment">     * 先找第一个字母不同的邻居,找到的全放进Set存储</span></span><br><span class="line"><span class="comment">     * 邻居next 先赋start值，循环的改变，有和字典对上就放Set里，直到字典遍历完</span></span><br><span class="line"><span class="comment">     * 没找到目标，上回合的元素出队，next全入队，重复</span></span><br><span class="line"><span class="comment">     * 读取过的邻居设置为已访问-放进Set里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 先设置一个小字典进行测试</span></span><br><span class="line"><span class="comment">     * 先在while里面写好在模块化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 现在的目标是找到起点到终点的最短路</span></span><br><span class="line"><span class="comment">     * 目前的处境是会输出所有遍历到的单词</span></span><br><span class="line"><span class="comment">     * 读文档发现了重要信息：Queue中存储的是每个单词梯子，而不是简单的单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Lexicon test = &#123;<span class="string">&quot;con&quot;</span>, <span class="string">&quot;cot&quot;</span>, <span class="string">&quot;bot&quot;</span>, <span class="string">&quot;bat&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;pit&quot;</span>, <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;big&quot;</span>, <span class="string">&quot;dig&quot;</span>&#125;;</span><br><span class="line">    Set&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.enqueue(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; start &lt;&lt; &quot; enqueue &quot;&lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> word = q.peek();</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == end)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; q.peek() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Finally finished！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成相邻词并检验入队</span></span><br><span class="line">        travalCheck(test, visited, q, word);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成一次查找邻居后将第一位出队，避免死循环</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.dequeue() &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (!q.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cout all visited value</span></span><br><span class="line"><span class="comment">    for (string find : visited)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; find &lt;&lt; &quot; visited!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vector 和 SPL 库里的 Vector 是<strong>两个</strong>类型 ！差点丢大人了<br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2024/png/40756445/1710837745888-b0d9a2eb-4142-4ce0-b6b9-1ec4b0dcc446.png#averageHue=%23a8d2ab&clientId=uad028b80-b53c-4&from=paste&height=533&id=uab82259b&originHeight=932&originWidth=700&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=93171&status=done&style=none&taskId=u760f884a-14ad-4fc0-be7a-ceb4f699ccd&title=&width=400'><img src="https://cdn.nlark.com/yuque/0/2024/png/40756445/1710837745888-b0d9a2eb-4142-4ce0-b6b9-1ec4b0dcc446.png#averageHue=%23a8d2ab&clientId=uad028b80-b53c-4&from=paste&height=533&id=uab82259b&originHeight=932&originWidth=700&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=93171&status=done&style=none&taskId=u760f884a-14ad-4fc0-be7a-ceb4f699ccd&title=&width=400" alt="image.png"></p>
<p>重整思路：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建字典实现 con -&gt; cot -&gt; bot -&gt; bit -&gt; pit -&gt; pig</span></span><br><span class="line">Lexicon test = &#123;<span class="string">&quot;con&quot;</span>, <span class="string">&quot;cot&quot;</span>, <span class="string">&quot;bot&quot;</span>, <span class="string">&quot;bat&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;pit&quot;</span>, <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;big&quot;</span>, <span class="string">&quot;dig&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//已访问集合</span></span><br><span class="line">Set&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">Queue&lt;Vector&lt;<span class="built_in">string</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">Vector&lt;<span class="built_in">string</span>&gt; ladder = &#123;start&#125;;</span><br><span class="line">visited.add(start);</span><br><span class="line">q.enqueue(ladder);</span><br><span class="line"><span class="type">int</span> len = start.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//返回当前ladder长度的函数，假设</span></span><br><span class="line">    <span class="type">int</span> nowend = ladder.size() - <span class="number">1</span>;</span><br><span class="line">    Vector&lt;<span class="built_in">string</span>&gt; check = q.peek();</span><br><span class="line">    <span class="keyword">if</span> (check[nowend] == end)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.peek() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//若数组末位为end，输出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ladder没有完成，弹出队首并更新</span></span><br><span class="line">    q.dequeue();</span><br><span class="line">    ladder = q.peek();</span><br><span class="line">    <span class="comment">//找邻居函数,假设有邻居word</span></span><br><span class="line">    <span class="built_in">string</span> tempw = check[nowend];</span><br><span class="line">    <span class="built_in">string</span> word = tempw;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        Vector&lt;<span class="built_in">string</span>&gt; tempv = ladder;<span class="comment">//进行ladder复位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> j = <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++)&#123;</span><br><span class="line">            word[i] = j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加一个word形成一个ladder，然后复位，再加另一个word再形成一个ladder，直到全部访问</span></span><br><span class="line">            <span class="keyword">if</span> (test.contains(word) &amp;&amp; !visited.contains(word))&#123;</span><br><span class="line">                tempv.add(word);</span><br><span class="line">                q.enqueue(tempv);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        word = tempw;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现了读取每个 ladder 的末位，检测是否为 end 值，遇到访问空队列 peek 的错误，debug 模式发现 line 22 dequeue 后又访问队首，初次将会报错。</p>
<p>注意暂时未完成返回当前 ladder 长度的函数，随手补上。<br />开始调试，哎，怎么还是死循环，看一下输出…哎呀，抱一丝，忘记把 word 设置为已访问了【挠头】，补上</p>
<p>再次测试，球进啦！！！！芜湖！！！！起飞！！！！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lease enter the source word [<span class="keyword">return</span> to quit]: con</span><br><span class="line">Please enter the destination word [<span class="keyword">return</span> to quit]: big</span><br><span class="line">Here<span class="number">&#x27;</span>s where yo<span class="string">u&#x27;ll search for a word ladder connecting &quot;con&quot; to &quot;big&quot;.</span></span><br><span class="line"><span class="string">&#123;&quot;con&quot;&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;con&quot;, &quot;cot&quot;&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;con&quot;, &quot;cot&quot;, &quot;bot&quot;&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;con&quot;, &quot;cot&quot;, &quot;bot&quot;, &quot;bat&quot;&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;con&quot;, &quot;cot&quot;, &quot;bot&quot;, &quot;bat&quot;, &quot;bit&quot;&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;con&quot;, &quot;cot&quot;, &quot;bot&quot;, &quot;bat&quot;, &quot;bit&quot;, &quot;pit&quot;&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;con&quot;, &quot;cot&quot;, &quot;bot&quot;, &quot;bat&quot;, &quot;bit&quot;, &quot;big&quot;&#125;</span></span><br><span class="line"><span class="string">&#123;&quot;con&quot;, &quot;cot&quot;, &quot;bot&quot;, &quot;bat&quot;, &quot;bit&quot;, &quot;big&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>后续将转入大字典进行压力测试。</p>
<h1 id="maze-Generator"><a href="#maze-Generator" class="headerlink" title="maze-Generator"></a>maze-Generator</h1><p>耗时良久，至少两周，发现还是不要完全脱离 AI 辅助，否则效率太低。</p>
<h2 id="读源码"><a href="#读源码" class="headerlink" title="读源码"></a>读源码</h2><h3 id="maze-types-h"><a href="#maze-types-h" class="headerlink" title="maze-types.h"></a>maze-types.h</h3><p>提供了 cell 与 wall 类型可供使用</p>
<p>cell 类接受 <code>int row; int col;</code><br />并重载了<code>&lt;</code>运算符: 返回 row1 &lt; row2 或 row1 &#x3D;&#x3D; row2 &amp;&amp; col1 &lt; col2 的真假。</p>
<p>wall 类 含有两个参数 <code>cell one; cell two;</code><br /><code>&lt;</code>运算符与 cell 类同理…<br />wait,看看这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> operator&lt;(<span class="type">const</span> wall&amp; one, <span class="type">const</span> wall&amp; two) &#123;</span><br><span class="line">    <span class="keyword">if</span> (one.one &lt; two.one) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (two.one &lt; one.one) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> one.two &lt; two.two;</span><br><span class="line">&#125; <span class="comment">// yes, this is somewhat arbitrary（专横的）, but it can be arbitrary as long as it&#x27;s consistent</span></span><br></pre></td></tr></table></figure>

<p>额，<code>return one.two &lt; two.two;</code>是什么意思？<br />哦，懂了：对 wall1 的 cell2 与 wall2 的 cell2 进行比较， 运算符含义为上文提及的方式。</p>
<h3 id="maze-graphics-h"><a href="#maze-graphics-h" class="headerlink" title="maze-graphics.h"></a>maze-graphics.h</h3><p>这里有很多图形接口，但是没有当时看 lifegame 的图形接口时头大了</p>
<p><code>MazeGeneratorView(); ~MazeGeneratorView();</code> 展示(~销毁)一个清空（clear）的界面给别的函数功能在此画图<br /><code>void setDimension(int dimension);</code> 设置迷宫的大小，强制方形<br /><code>void drawBorder();</code> 在边界画出界限<br /><code>void addOneWall(const wall&amp; w);</code> 只是加一堵墙（不是画出来），想展示就调用<code>view.repaint()</code></p>
<p>下面这个是个大件儿：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method: addAllWalls</span></span><br><span class="line"><span class="comment"> * ----------------</span></span><br><span class="line"><span class="comment"> * Adds (but does not display) all the walls contained within the parameter.</span></span><br><span class="line"><span class="comment"> * To display all newly-added walls on the screen, call view.repaint();</span></span><br><span class="line"><span class="comment"> * Optimized for speed as compared to several sequential calls to addOneWall.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function requires that the parameter passed in is, in fact, a collection</span></span><br><span class="line"><span class="comment"> * that can be iterated through and that contains wall objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    template &lt;typename C&gt;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">addAllWalls</span><span class="params">(<span class="type">const</span> C&amp; collection)</span> &#123; addAllWalls(collection.begin(), collection.end()); &#125;</span><br><span class="line">    <span class="comment">// defined inline as required by template type</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加（但不显示）参数中包含的所有墙壁。</li>
<li>要在屏幕上显示所有新添加的墙壁，请调用 view.repaint();</li>
<li>与依次调用 addOneWall 相比，针对速度进行了优化。</li>
<li>此函数要求传入的参数实际上是一个可以迭代且包含墙壁对象的集合。</li>
</ul>
<p>typename C 意味着可以接受各种类型的 collection，比如说 Set，Vector 之类的</p>
<p><code>void removeWall(const wall&amp; w);</code>移除数据里的 wall，用<code>repaint()</code>更新画面</p>
<p><code>void repaint() &#123; GWindow::repaint(); &#125; // inlined for convenience</code> 唯一真神！更新画面</p>
<p>私有变量先不看了。</p>
<h2 id="开展"><a href="#开展" class="headerlink" title="开展"></a>开展</h2><p>简单说就是如果两边的房间封闭，就把这堵墙拆掉</p>
<p>额，简单仿照 ifle game 进行了窗口化显示，然后该干嘛？</p>
<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>仔细读了读接口文件，试了试把图形画出来，wall 类型在两个 cell 类型中间，为其赋值<code>wall wx &#123;cx1, cy1&#125;; wall wy &#123;cx2, cy2&#125;;</code>,再对边界和出入口优化一下，就把左右文档中的图一画出来了。这就折腾了有一阵子，哎 😔</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化房间与墙壁</span></span><br><span class="line">Set&lt;wall&gt; swall;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dimension; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dimension; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = j + <span class="number">1</span>, y = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; dimension || x &lt; <span class="number">0</span> || y &gt; dimension || y &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cell c1&#123;i, j&#125;;</span><br><span class="line">            cell c2&#123;i, j + <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">            cell y1&#123;i, j&#125;;</span><br><span class="line">            cell y2&#123;i + <span class="number">1</span>, j&#125;;</span><br><span class="line"></span><br><span class="line">            wall w&#123;c1, c2&#125;;</span><br><span class="line">            wall wy&#123;y1, y2&#125;;</span><br><span class="line">            swall.add(w);  <span class="comment">// x方向的墙</span></span><br><span class="line">            swall.add(wy); <span class="comment">// y方向的墙</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// display.addOneWall(wy);</span></span><br><span class="line">            <span class="comment">// display.addOneWall(w);</span></span><br><span class="line">            <span class="comment">// display.repaint();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">display.addAllWalls(swall);</span><br><span class="line">getLine(<span class="string">&quot;press [enter] to continue...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后是擦除部分，完全没有思路…<br />再看看作业文档<br />问了问 ai，好快的思路！把联通的房间放到一个集合内，两房间不在一个集合就把之间的墙壁删除。</p>
<p>按照与生成墙壁类似的代码结构编写了移除墙壁的代码，仿照 wordladder 进行是否位于集合的检测，大体方向是对了，成功移除了部分墙壁，但是边界没有控制好，因为是随机访问，并不是所有房间都检测过了。</p>
<p>重新看一下代码：while 循环条件为 oneRoom 集合的大小小于房间数，而对房间的访问是随机的，无法保证所有房间在 dimension2 内全部被访问到…不对<br />擦除的逻辑有问题，重写<br />重新理解墙壁的生成原理，重读 maze-types.h<br />x，y 方向相邻两个 cell 之间可以有 wall</p>
<p>怎么还是会在最下和最右边画线啊啊啊啊</p>
<blockquote>
<p>你的 <code>if (i + 1 &gt;= dimension || j + 1 &gt;= dimension) continue; </code>语句会跳过最后一行和最后一列的所有房间，这意味着这些房间不会有任何墙壁。这并不是你想要的结果，你只是想避免在最后一行和最后一列的房间添加右边和下面的墙。<br>你应该将这个 if 语句应用到添加墙壁的部分，而不是应用到整个循环。</p>
</blockquote>
<p>成功绘制正确的起始图</p>
<p>在想擦除墙壁的循环结构时想看看 Set 库有没有 isEmpty 函数，结果猜猜我发现了什么？<br /><strong>shuffle.h</strong>!! 让我看看！<br />哦我的天哪，可以打乱数组，二维数组，<del>集合</del>，字符串。这样就不用自己生成随机数访问了，太棒了。<br />怎么没有这个库啊，算了，用 CPP 提供的 shuffle 吧</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 擦除部分</span></span><br><span class="line"><span class="comment"> * 如果两个房间不在同一个集合内，则擦去墙壁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Set&lt;cell&gt; oneRoom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打乱allwall数组，然后一个个遍历两边的房间是否在一个集合内</span></span><br><span class="line">random_device rd;</span><br><span class="line">mt19937 <span class="title function_">g</span><span class="params">(rd())</span>;</span><br><span class="line">shuffle(allwall.begin(), allwall.end(), g);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; allwall.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// check if two room</span></span><br><span class="line">    <span class="comment">//ERROR! 可能因为其他墙壁的处理导致被墙分隔的房间都被放进了oneRoom集合内</span></span><br><span class="line">    <span class="keyword">if</span> (oneRoom.contains(allwall[i].one) &amp;&amp; oneRoom.contains(allwall[i].two))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        display.removeWall(allwall[i]);</span><br><span class="line">        oneRoom.add(allwall[i].one);</span><br><span class="line">        oneRoom.add(allwall[i].two);</span><br><span class="line">        display.repaint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getLine(<span class="string">&quot;press [enter] to again.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>结果产生了一些逻辑错误<br />可能因为其他墙壁的处理导致被墙分隔的房间都被放进了 oneRoom 集合内</p>
<blockquote>
<p>在迷宫生成中，最小生成树（Minimum Spanning Tree，MST）是一种常用的方法。它可以确保生成的迷宫是完全连通的（即，任意两个房间之间都存在一条路径），并且没有环路（这是迷宫的一个重要特性）。<br>在你的代码中，你可以使用 Kruskal 算法来生成最小生成树。Kruskal 算法的基本思想是：首先，将所有的墙放入一个列表，并随机打乱这个列表。然后，依次考虑每一堵墙，如果这堵墙两边的房间不在同一个集合中（这可以用并查集来判断），那么就拆除这堵墙，并将两个房间合并到同一个集合中。这样，当所有的墙都被考虑过后，就生成了一个迷宫。<br>在你的代码中，你已经实现了这个算法的大部分步骤，但是你使用了一个简单的集合 oneRoom 来存储所有已经连接的房间，这并不能正确地处理所有的情况。你应该使用一个并查集来替换这个集合，这样就可以正确地生成迷宫了。</p>
</blockquote>
<p>并查集……广搜和深搜也可以，但是会复杂一些<br />&#x2F;&#x2F; 3.30 补充了并查集的知识</p>
<h3 id="unionFind"><a href="#unionFind" class="headerlink" title="unionFind"></a>unionFind</h3><p>然后一通操作猛如虎，一构建错麻了：什么没有运算方法，无法调用 shuffle 函数，函数名调用错误…<br />别急别急别急，修好后一运行——访问空数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief unionFind 并查集</span></span><br><span class="line"><span class="comment"> * 初始化 每个cell指向其头部，二维数组的索引表示每个cell，存储的内容为其头部</span></span><br><span class="line"><span class="comment"> * 合并   传入两个参数，将其合并：某个索引的cell值改为新的头部</span></span><br><span class="line"><span class="comment"> * 检测   检测两个cell参数的头部是否相同</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Vector&lt;Vector&lt;cell&gt;&gt; initunionFind(<span class="type">int</span> dimension) &#123;</span><br><span class="line">    <span class="comment">//初始化二维cell数组，且每个cell的头部为自身</span></span><br><span class="line">    Vector&lt;Vector&lt;cell&gt;&gt; oneCell;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dimension; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dimension; j++) &#123;</span><br><span class="line">            cell c&#123;i, j&#125;;</span><br><span class="line">            oneCell[i][j] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oneCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operator ==(cell c1, cell c2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c1.row == c2.row &amp;&amp; c1.col == c2.col) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">test</span><span class="params">(cell c1, cell c2, Vector&lt;Vector&lt;cell&gt;&gt; oneCell)</span> &#123;</span><br><span class="line">    <span class="comment">//cell 类型无法进行==运算，不想重载操作符了。。。最后还是重载了</span></span><br><span class="line">    <span class="keyword">return</span> oneCell[c1.row][c1.col] == oneCell[c2.row][c2.col];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">follow</span><span class="params">(cell boss, cell follower, Vector&lt;Vector&lt;cell&gt;&gt; oneCell)</span> &#123;</span><br><span class="line">    oneCell[follower.row][follower.col] = boss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦~我大概知道了，初始化 oneCell 的时候我们希望按照二维数组的方式进行，但是 oneCell[i][j]的值其实是 Vector<cell>,暂时改成 Grid<cell> oneCell(dimension, dimension); 主要是用括号括一下范围，这个 忘记了。</p>
<p>一运行，呃呃，所有的墙都被擦掉了。其实对此有些预感：follow 函数太简单了，不能保证指向头部，想起来了！用 while 循环直到存储的 cell 与索引一致的 findHead 函数！</p>
<p>重整思路：</p>
<ul>
<li>初始化并查集 init</li>
<li>检测墙是否将两个房间隔开 test（两个索引内存储的 cell 是否相同 i.e.两 cell 是否有一个 Head）<ul>
<li>Yes：continue</li>
<li>No：拆墙；把 cell 的 Head 统一<ul>
<li>起初：每个索引存储其自身</li>
<li>需要合并：将一个的索引存储的内容改为另一个房间 follow</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>问了问 ai，是在 merge 合并时出了问题：让 c2 从 c1 时会将 c2 与从 c2 的所有子集分隔</p>
<p>嗷嗷嗷！</p>
<blockquote>
<p>为了确保 c2 集合的所有元素都指向 c1，我们需要对 merge 函数进行修改。在并查集中，合并两个集合的基本思想是将一个集合的根节点直接指向另一个集合的根节点。在这个过程中，我们需要确保路径压缩被正确应用，以避免形成冗长的链式结构，这样可以提高查询效率。<br>下面是修改后的 merge 函数，它确保了 c2 集合的所有元素都指向 c1 集合的根节点：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(cell c1, cell c2, Grid&lt;cell&gt; &amp;oneCell)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找c1和c2的根节点</span></span><br><span class="line">    cell root1 = <span class="built_in">findHead</span>(c1, oneCell);</span><br><span class="line">    cell root2 = <span class="built_in">findHead</span>(c2, oneCell);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个节点已经相同，不需要合并</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == root2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将root2指向root1，即将c2集合的所有元素指向c1集合的根节点</span></span><br><span class="line">    oneCell[root2.row][root2.col] = root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个函数中，我们首先找到 c1 和 c2 的根节点，即代表它们所在集合的节点。如果两个根节点已经相同，说明这两个集合已经合并过了，不需要再次合并。如果根节点不同，我们将 c2 的根节点直接指向 c1 的根节点，这样就完成了两个集合的合并。</p>
</blockquote>
<p>我的代码<code>oneCell[c2.row][c2.col] = findHead(c1, oneCell);</code>直接修改 c2 的值，而不是 root 的值，进而无法有效变更头部。</p>
<p>done。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File: maze-generator.cpp</span></span><br><span class="line"><span class="comment"> * ------------------------</span></span><br><span class="line"><span class="comment"> * Presents an adaptation of Kruskal&#x27;s algorithm to generate mazes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">// for shuffle</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maze-graphics.h&quot;</span> <span class="comment">//竟然没预先引用！</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maze-types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getMazeDimension</span><span class="params">(string prompt,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> minDimension = <span class="number">7</span>, <span class="type">int</span> maxDimension = <span class="number">50</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> response = <span class="built_in">getInteger</span>(prompt);</span><br><span class="line">        <span class="keyword">if</span> (response == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        <span class="keyword">if</span> (response &gt;= minDimension &amp;&amp; response &lt;= maxDimension)</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter a number between &quot;</span></span><br><span class="line">             &lt;&lt; minDimension &lt;&lt; <span class="string">&quot; and &quot;</span></span><br><span class="line">             &lt;&lt; maxDimension &lt;&lt; <span class="string">&quot;, inclusive.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief unionFind 并查集</span></span><br><span class="line"><span class="comment"> * 初始化 每个cell指向其头部，二维数组的索引表示每个cell，存储的内容为其头部</span></span><br><span class="line"><span class="comment"> * 合并   传入两个参数，将其合并：某个索引的cell值改为新的头部</span></span><br><span class="line"><span class="comment"> * 检测   检测两个cell参数的头部是否相同</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> Grid&lt;cell&gt; <span class="title">initunionFind</span><span class="params">(<span class="type">int</span> dimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化二维cell数组，且每个cell的头部为自身</span></span><br><span class="line">    <span class="function">Grid&lt;cell&gt; <span class="title">oneCell</span><span class="params">(dimension, dimension)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dimension; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dimension; j++) &#123;</span><br><span class="line">            cell c&#123;i, j&#125;;</span><br><span class="line">            oneCell[i][j] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oneCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载运算符</span></span><br><span class="line"><span class="keyword">operator</span> ==(cell c1, cell c2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c1.row == c2.row &amp;&amp; c1.col == c2.col) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO findHead, 路径压缩</span></span><br><span class="line"><span class="function"><span class="type">static</span> cell <span class="title">findHead</span><span class="params">(cell c1, Grid&lt;cell&gt; &amp;oneCell)</span></span>&#123;</span><br><span class="line">    cell top = oneCell[c1.row][c1.col];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当索引指向其他cell时</span></span><br><span class="line">    <span class="keyword">while</span> (!(top == oneCell[top.row][top.col])) &#123;</span><br><span class="line">        top = oneCell[top.row][top.col];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径压缩</span></span><br><span class="line">    oneCell[c1.row][c1.col] = top;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同头检测</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(cell c1, cell c2, Grid&lt;cell&gt; &amp;oneCell)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cell 类型无法进行==运算，不想重载操作符了。。。最后还是重载了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findHead</span>(c1, oneCell) == <span class="built_in">findHead</span>(c2, oneCell);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 合并操作 c2从c1</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(cell c1, cell c2, Grid&lt;cell&gt; &amp;oneCell)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//oneCell[c2.row][c2.col] = findHead(c1, oneCell);</span></span><br><span class="line">    cell root1 = <span class="built_in">findHead</span>(c1, oneCell);</span><br><span class="line">    cell root2 = <span class="built_in">findHead</span>(c2, oneCell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root1 == root2)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    oneCell[root2.row][root2.col] = root1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> dimension = <span class="built_in">getMazeDimension</span>(<span class="string">&quot;What should the dimension of your maze be [0 to exit]? &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dimension == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is where I&#x27;d animate the construction of a maze of dimension &quot;</span> &lt;&lt; dimension &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * i think i should do from here</span></span><br><span class="line"><span class="comment">         * 生成所有的墙壁</span></span><br><span class="line"><span class="comment">         * 擦去起始点的墙壁，随机擦去迷宫内的一堵墙</span></span><br><span class="line"><span class="comment">         * 如果一堵墙分隔了两个房间，把墙擦去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基础显示</span></span><br><span class="line">        MazeGeneratorView display = <span class="built_in">MazeGeneratorView</span>(); <span class="comment">// 和lifegame题一样的接口调用</span></span><br><span class="line">        display.<span class="built_in">setDimension</span>(dimension);</span><br><span class="line">        display.<span class="built_in">drawBorder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化房间与墙壁</span></span><br><span class="line">        <span class="comment">// 问题：无法避免绘制右，下与边界重合的墙壁 双if判断解决</span></span><br><span class="line">        Vector&lt;wall&gt; allwall;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dimension; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dimension; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; dimension)</span><br><span class="line">                &#123;</span><br><span class="line">                    cell left&#123;i, j&#125;;</span><br><span class="line">                    cell right&#123;i, j + <span class="number">1</span>&#125;;</span><br><span class="line">                    wall horizon&#123;left, right&#125;;</span><br><span class="line">                    allwall.<span class="built_in">add</span>(horizon);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; dimension)</span><br><span class="line">                &#123;</span><br><span class="line">                    cell up&#123;i, j&#125;;</span><br><span class="line">                    cell down&#123;i + <span class="number">1</span>, j&#125;;</span><br><span class="line">                    wall vertical&#123;up, down&#125;;</span><br><span class="line">                    allwall.<span class="built_in">add</span>(vertical);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        display.<span class="built_in">addAllWalls</span>(allwall);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 擦除部分</span></span><br><span class="line"><span class="comment">         * 如果两个房间不在同一个集合内，则擦去墙壁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 创建并查集</span></span><br><span class="line"><span class="comment">         * 每一个cell是一个子集，每擦除一堵墙，将两个子集合并，直到仅剩一个总集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 打乱allwall数组，然后一个个遍历两边的房间是否在一个集合内</span></span><br><span class="line">        random_device rd;</span><br><span class="line">        <span class="function">mt19937 <span class="title">g</span><span class="params">(rd())</span></span>;</span><br><span class="line">        <span class="built_in">shuffle</span>(allwall.<span class="built_in">begin</span>(), allwall.<span class="built_in">end</span>(), g);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//shuffle(allwall);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化并查集</span></span><br><span class="line">        Grid&lt;cell&gt; oneCell = <span class="built_in">initunionFind</span>(dimension);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始擦除！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, len = allwall.<span class="built_in">size</span>(); i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">test</span>(allwall[i].one, allwall[i].two, oneCell)) &#123;</span><br><span class="line">                display.<span class="built_in">removeWall</span>(allwall[i]);</span><br><span class="line">                display.<span class="built_in">repaint</span>();</span><br><span class="line">                <span class="built_in">merge</span>(allwall[i].one, allwall[i].two, oneCell);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">getLine</span>(<span class="string">&quot;press [enter] to again.&quot;</span>);</span><br><span class="line">        <span class="comment">// display.~MazeGeneratorView();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间紧迫，暂时不重构了。<br />继续看接下来的课，递归是真的怪异，weird。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/04/11/Hexo%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/">← Next Hexo使用备忘</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/03/09/CS106-lec0-3/">CS106-lec0~3 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Qs Wang</a></h1><div id="description"><p>网页描述</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#word-Ladder-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.</span> <span class="toc-text">word-Ladder 广度优先搜索</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#maze-Generator"><span class="toc-number">2.</span> <span class="toc-text">maze-Generator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%BA%90%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">读源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#maze-types-h"><span class="toc-number">2.1.1.</span> <span class="toc-text">maze-types.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maze-graphics-h"><span class="toc-number">2.1.2.</span> <span class="toc-text">maze-graphics.h</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%B1%95"><span class="toc-number">2.2.</span> <span class="toc-text">开展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#display"><span class="toc-number">2.2.1.</span> <span class="toc-text">display</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unionFind"><span class="toc-number">2.2.2.</span> <span class="toc-text">unionFind</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">copyright</span><a class="icp-content" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/lib/encrypt/hbe.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>