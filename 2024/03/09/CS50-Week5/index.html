<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>CS50-Week5 | RadiantFlame</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad: false});</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
  --theme-encrypt-confirm: 'confirm'
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>CS50-Week5</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-03-09T13:46:13.000Z" id="date"> 2024-03-09</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-03-09T13:48:58.831Z" id="updated"> 2024-03-09</time></div></span><br><span>Word Count: <div class="control">4.6k</div></span><br><span>Read Time: <div class="control">19 min</div></span></div></div><hr><div id="post-content"><p>完成了指针的部分！真的很难，这一部分反复看了五六遍视频，又看 Notes，好在完全搞明白了。</p>
<span id="more"></span>

<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><h2 id="链表与内存分配"><a href="#链表与内存分配" class="headerlink" title="链表与内存分配"></a>链表与内存分配</h2><p>目标：创建一个链表，像其中存入 10 个数且不发生内存泄漏<br />思路：创建一个列表 list ，再创建一个 node 节点用于初始化链表数值，接着进入 for 循环，在循环内设置赋值语句。<br />以设置一个 1，2，3，4，5……的链表举例，设置一个用于分配数值的节点 node *n,访问 n 内的数值，然后将 list 指向该节点，指向后 list 需要继续向下指，为能继续创建节点，将 n 的 next 地址设置为 list，然后将 n 的地址赋给 list<br />读取链表需要设置一个临时指针 ptr，将 ptr 初始化为 list，进入循环，当 ptr 不为空时：打印 ptr 所指的数字值，然后将所指 next 赋给 ptr，使其指向下一位置，循环<br />内存释放：每释放一个节点前需要记录下一节点的地址，设置 next 节点，在释放当前节点前记录当前节点 ptr 的 next 所指，然后释放当前内存，将 next 记录的地址赋给 ptr，循环</p>
<p>新建一个 node 结构体，包含 int number ；node *next;<br />即一个数字，一个 node 型地址，自引用需要使用语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> number;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;node;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stido.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> number;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;node;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    node *<span class="hljs-built_in">list</span> = <span class="hljs-literal">NULL</span>;<br>    node *nlist = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>    <span class="hljs-keyword">if</span> (nlist == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nlist = NULL\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        node *n = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">free</span>(nlist);<br>            <span class="hljs-built_in">free</span>(n);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        n-&gt;number = i;<br>        n-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>        n-&gt;next = <span class="hljs-built_in">list</span><br>        <span class="hljs-built_in">list</span> = n;<br>    &#125;<br><br>    node *ptr = <span class="hljs-built_in">list</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>,ptr-&gt;number);<br>        ptr = ptr-&gt;next;<br>    &#125;<br><br>    ptr = <span class="hljs-built_in">list</span>;<br>    <span class="hljs-keyword">while</span> (ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        node *next = ptr-&gt;next;<br>        <span class="hljs-built_in">free</span>(ptr);<br>        ptr = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="树状二分"><a href="#树状二分" class="headerlink" title="树状二分"></a>树状二分</h2><p>每个节点带有左右指针，递归的分配，若待查数值大于当前地址的数值，读取右地址，并返回……<br />当值相等时，返回。<br />对于一些特殊情况，例如所有值均在某一侧使树形成链表结构，可以优化，将中间值设置为根……</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>作为字典的一种，具有键值对 key-value，即索引与值<br />对于人名排序，设置 26 个 bucket，存储人名的首字母。理想情况下，可以将 O（n）将为 O（1）。<br />对于多个相同数字母的人名，将原先的 ABC 哈希表进行扩展，为 AA,AB，AC……<br />对于哈希表，哈希函数为每个首字母的名字分配对应 bucket 值 1，2，3…26.<br />实现：<br />途中发现的问题：</p>
<blockquote>
<p>you<br>char list 和 char *list 有什么区别<br>ddb<br>在 C 语言中，char list 和 char *list 是两种不同的数据类型。<br>char list 表示一个字符变量，它可以存储一个字符。<br>而 char *list 是一个字符指针，它存储的是字符的地址，通常用于指向一个字符数组的开始。这样，通过这个指针，我们可以访问和操作这个字符数组。<br>这两者的主要区别在于它们存储的内容和它们的用途。</p>
</blockquote>
<p>char 只能存储单字符，将其设置为地址变量就可以在首字母后面不断存储字符了</p>
<h2 id="Trie-前缀树"><a href="#Trie-前缀树" class="headerlink" title="Trie-前缀树"></a>Trie-前缀树</h2><p>更高级的字典树结构，每个节点都是一个数组，每个数组可以指向像一个数组，对于查找人们即对每一个字母排序<br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2024/png/40756445/1706425957220-5b330391-7fe1-49f2-9a4a-364eff48196f.png#averageHue=%23211e25&clientId=u79c46a4c-74f6-4&from=paste&height=253&id=u05b18b44&originHeight=443&originWidth=853&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=191518&status=done&style=none&taskId=u100ef616-4663-4ee9-951a-14ae1ab4f91&title=&width=487.42857142857144'><img src="https://cdn.nlark.com/yuque/0/2024/png/40756445/1706425957220-5b330391-7fe1-49f2-9a4a-364eff48196f.png#averageHue=%23211e25&clientId=u79c46a4c-74f6-4&from=paste&height=253&id=u05b18b44&originHeight=443&originWidth=853&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=191518&status=done&style=none&taskId=u100ef616-4663-4ee9-951a-14ae1ab4f91&title=&width=487.42857142857144" alt="image.png"><br />至此。</p>
<h1 id="Psets"><a href="#Psets" class="headerlink" title="Psets"></a>Psets</h1><h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><h3 id="Before-coding"><a href="#Before-coding" class="headerlink" title="Before coding"></a>Before coding</h3><h4 id="目标：家族血型遗传推测"><a href="#目标：家族血型遗传推测" class="headerlink" title="目标：家族血型遗传推测"></a>目标：家族血型遗传推测</h4><h4 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h4><ul>
<li>函数<code>create_family</code>接受一个整数作为输入，并返回对 person 的下一代的指针</li>
<li>每个 person 都有符合遗传学的 alleles，第 0 代的 allele 由<code>random_allele</code>函数随机选择</li>
<li>第 0 代的根设置为 NULL</li>
</ul>
<h4 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h4><p>allele<br />indent<br />recursion 递归</p>
<h3 id="Understanding"><a href="#Understanding" class="headerlink" title="Understanding"></a>Understanding</h3><p>首先，导入库 stdbool stdio stdllib time<br />接着程序构建了 person 结构体，内置了一个大小为 2 的 parent 指针，大小为 2 的 allels 字符串<br />初始化一些常量，generation，indent length。<br />函数声明<code>person *create_famliy(int generations);</code>以及打印家庭，释放内存，随机血型等函数功能<br />然后进入 main 函数，main<br />函数不接受命令行输入参数，由 srand（time（0））开始，利用当前时间生成随机种子；<br />调用 create_family 函数并赋值给 person 类型的指针 p<br />createfamliy 函数为 person 型指针赋值，</p>
<p>print_family(p,0);接受两个参数，用于输出家庭血型<br />最后释放内存 free_family(p);</p>
<p>来看声明函数的细节<br /><code>person *create_family(int generations)</code><br />首先，为 new person 分配内存<br />接判断：还有下一代，则继续创建 new person<br />然后为其创建父指针，然后为其分配血型<br />任何非 generation &gt; 1 的情况，即第 0 代，设置父指针为 NULL 并随机设置血型<br />出判断，返回创建的 new 　 person;return NULL;</p>
<p><code>void free_family(person *p)</code><br />三项代办：handle base case ；free parents recursively; free child; 其实是我没看懂要干嘛</p>
<p><code>void print_family(person *p,int generation)</code><br />本部分代码已给出，同样有 handle base case<br />即首先进入判断 若 p &#x3D;&#x3D; NULL 则返回<br />出判断，进入打印空字符的循环，用于输出格式化<br />再进判断，用于输出 person，当 generation &#x3D;&#x3D; 0 输出子代血型信息<br />其他判断条件同理<br />最后调任两次自身以输出亲代信息（大概</p>
<p><code>char random_allele()</code><br />用于随机选择血型，基于随机数 mol 3 的余数进行赋型。</p>
<h3 id="Walkthrough"><a href="#Walkthrough" class="headerlink" title="Walkthrough"></a>Walkthrough</h3><p><del>开始着手后发现还是回去练练 malloc 再说吧</del>搞定,写完再回头看真的挺简单的。</p>
<p>对于地址型的函数，若 malloc 失败应返回 NULL</p>
<p>关于字符串，其实就是 array</p>
<p>递归地使用函数</p>
<h3 id="SourceCode"><a href="#SourceCode" class="headerlink" title="SourceCode"></a>SourceCode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Simulate genetic inheritance of blood type</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// Each person has two parents and two alleles</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">parents</span>[2];</span><br>    <span class="hljs-type">char</span> alleles[<span class="hljs-number">2</span>];<br>&#125; person;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> GENERATIONS = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INDENT_LENGTH = <span class="hljs-number">4</span>;<br><br>person *<span class="hljs-title function_">create_family</span><span class="hljs-params">(<span class="hljs-type">int</span> generations)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_family</span><span class="hljs-params">(person *p, <span class="hljs-type">int</span> generation)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">free_family</span><span class="hljs-params">(person *p)</span>;<br><span class="hljs-type">char</span> <span class="hljs-title function_">random_allele</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// Seed random number generator</span><br>    srand(time(<span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// Create a new family with three generations</span><br>    person *p = create_family(GENERATIONS);<br><br>    <span class="hljs-comment">// Print family tree of blood types</span><br>    print_family(p, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Free memory</span><br>    free_family(p);<br>&#125;<br><br><span class="hljs-comment">// Create a new individual with `generations`</span><br>person *<span class="hljs-title function_">create_family</span><span class="hljs-params">(<span class="hljs-type">int</span> generations)</span><br>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Allocate memory for new person</span><br>    person *newPerson = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(person));<br>    <span class="hljs-keyword">if</span> (newPerson == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// If there are still generations left to create</span><br>    <span class="hljs-keyword">if</span> (generations &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// Create two new parents for current person by recursively calling create_family</span><br>        person *parent0 = create_family(generations - <span class="hljs-number">1</span>);<br>        person *parent1 = create_family(generations - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Set parent pointers for current person</span><br>        person-&gt;parent0 =<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Randomly assign current person&#x27;s alleles based on the alleles of their parents</span><br>    &#125;<br><br>    <span class="hljs-comment">// If there are no generations left to create</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Set parent pointers to NULL</span><br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Randomly assign alleles</span><br>    &#125;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return newly created person</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// Free `p` and all ancestors of `p`.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_family</span><span class="hljs-params">(person *p)</span><br>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Handle base case</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>    &#123;<br><br>    &#125;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Free parents recursively</span><br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Free child</span><br>&#125;<br><br><span class="hljs-comment">// Print each family member and their alleles.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_family</span><span class="hljs-params">(person *p, <span class="hljs-type">int</span> generation)</span><br>&#123;<br>    <span class="hljs-comment">// Handle base case</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Print indentation</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; generation * INDENT_LENGTH; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Print person</span><br>    <span class="hljs-keyword">if</span> (generation == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child (Generation %i): blood type %c%c\n&quot;</span>, generation, p-&gt;alleles[<span class="hljs-number">0</span>], p-&gt;alleles[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (generation == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent (Generation %i): blood type %c%c\n&quot;</span>, generation, p-&gt;alleles[<span class="hljs-number">0</span>], p-&gt;alleles[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; generation - <span class="hljs-number">2</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Great-&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Grandparent (Generation %i): blood type %c%c\n&quot;</span>, generation, p-&gt;alleles[<span class="hljs-number">0</span>], p-&gt;alleles[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// Print parents of current generation</span><br>    print_family(p-&gt;parents[<span class="hljs-number">0</span>], generation + <span class="hljs-number">1</span>);<br>    print_family(p-&gt;parents[<span class="hljs-number">1</span>], generation + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// Randomly chooses a blood type allele.</span><br><span class="hljs-type">char</span> <span class="hljs-title function_">random_allele</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> r = rand() % <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;O&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="Speller"><a href="#Speller" class="headerlink" title="Speller"></a>Speller</h2><h3 id="Before-coding-1"><a href="#Before-coding-1" class="headerlink" title="Before coding"></a>Before coding</h3><h4 id="目标：最快的拼写检查器！"><a href="#目标：最快的拼写检查器！" class="headerlink" title="目标：最快的拼写检查器！"></a>目标：最快的拼写检查器！</h4><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>由于内容的复杂性，程序被拆分为多个子程序，详情见 understanding。</p>
<h4 id="Vocabulary-1"><a href="#Vocabulary-1" class="headerlink" title="Vocabulary"></a>Vocabulary</h4><p>theoretical 理论上<br />asymptotically equivalent<br />implement<br />prototype<br />benchmark</p>
<h4 id="Understanding-1"><a href="#Understanding-1" class="headerlink" title="Understanding"></a>Understanding</h4><h5 id="dictionary-h"><a href="#dictionary-h" class="headerlink" title="dictionary.h"></a>dictionary.h</h5><p>内涵一些新语法，但是不必太过关心<br />注意下#include &lt;stdbool.h&gt; 因为我们现在不再使用 cs50 库了<br />另一个点，#define 是 预处理器指令，定义了 length 的值为 45，写于文件开头，便于查找更改<br />接着声明函数。</p>
<h5 id="dictionary-c"><a href="#dictionary-c" class="headerlink" title="dictionary.c"></a>dictionary.c</h5><p>导入刚才的函数声明头文件<br />定义了一个哈希表的节点变量类型，内涵一个字符类，next 指针.使用 unsigned int 定义</p>
<blockquote>
<p>“unsigned int” 是 C 语言中的一种数据类型，它表示一个无符号整数。这意味着它只能存储正数或零，不能存储负数。这与 “int” 类型不同，后者可以存储正数、负数和零。”unsigned int” 的范围通常是从 0 到大约 4,000,000,000</p>
</blockquote>
<p>然后留了一个 TODO，让我们来选出哈希表里的 buckets，此外还实现了最基础的 load，check，size，unload 功能</p>
<h5 id="speller-c"><a href="#speller-c" class="headerlink" title="speller.c"></a>speller.c</h5><p>此文件无需修改<br />注意，我们使用了<code>getrusage</code>预处理器指令，前文#undef 即 undefine 取消定义之前定义过的宏，后续代码就可以使用 getrusage 而不会被预处理器替换掉。<br />定义了 speller 的用法为 <code>speller [dictionary] text</code>其中 dictionary 是一个存储字母的列表文件，如果没有指定字典种类，则默认使用 dictionary&#x2F;large;后面的 text 为待检测文本，需要待 load 函数成功读取 text 才可以正常运行，否则会提示 could not load<br />此处仅介绍 speller 的用法。</p>
<h5 id="text"><a href="#text" class="headerlink" title="text&#x2F;"></a>text&#x2F;</h5><p>存储了一堆文本的文件夹。</p>
<h3 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h3><p>请按照 load，hash，size，check，unload 的顺序设计程序<br />尽可能使 time 更小<br />不要修改 speller 和 Makefile<br />不要修改 dictionary.c&#x2F;h 中已经给出的函数声明<br />可以修改 N 的值<br />拼写检查无需关心大小写<br />记得用 valgrind 检测内存泄漏</p>
<h3 id="Walkthrough-1"><a href="#Walkthrough-1" class="headerlink" title="Walkthrough"></a>Walkthrough</h3><p>根据提示，优先处理 load 函数，含有一个字符串 dictionary 指针参数。<br />读取 dictionary 中的内容并写入哈希表，最后关闭字典。使用哈希表在哪里？<br /><del>……好喜欢这种刚拿到题目手足无措的感觉。</del>没什么思路，重新看看 spell.c 的运行逻辑…<br />看完了，准备开工。<br /><strong>bool load(const char *dictionary)</strong><br />加载字典，成功返回 ture，失败返回 false。<br />如何将文件读入内存？定义一个文件类型的指针 FILE *source<br />欢迎来自 stdio 库的文件读写相关函数 fopen,fread,fclose！<br>fopenfopen(“filename”,”mode”) <br />模式：r - read; w - write; a - append<br />返回值：打开的文件指针，失败返回 NULL<br />注意：随手跟 fclose 函数关闭文件;使用双引号。<br>freadfread(指向读入数据的第一位地址指针，每组读取内容的大小，每次读取几组，指向源文件 ie.使用 fopen 的文件指针)<br>fcloseif (filepoint !&#x3D; NULL) fclose(filepiont);<br />好，将字典文件读入内存吧，当文件成功打开时，需要创建一个缓冲区将字典全部存储进内存:<code>char buffer[size?]</code>size 应为字典的大小，如何得知？</p>
<blockquote>
<p>在 C 语言中，你可以使用 fseek 和 ftell 函数来确定文件的大小。首先，你可以使用 fseek 函数将文件指针移动到文件的末尾，然后使用 ftell 函数来获取当前的文件位置，这就是文件的大小。这是一个基本的示例：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *file = fopen(<span class="hljs-string">&quot;dictionary.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>fseek(file, <span class="hljs-number">0</span>, SEEK_END);<br><span class="hljs-type">long</span> size = ftell(file);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在这个例子中，size 变量就是文件的大小，单位是字节。注意，你需要在使用 ftell 函数之后使用 fseek 函数将文件指针重新定位到文件的开始，否则后续的读取操作可能会失败。</p>
</blockquote>
<p>完成读取后关闭文件<del>并返回 true。</del>你先别急<br />将读取的内容存入哈希表待查，哈希函数生成唯一值，直接读取数列中用同一函数生成并存储的对应值</p>
<blockquote>
<p><strong>you</strong><br>哈希表和字典树有什么区别<br><strong>ddb</strong><br>哈希表和字典树（Trie）都是用于存储和查找数据的数据结构，但它们的工作方式和效率有所不同。<br>哈希表通过使用哈希函数将键（通常是字符串）转换为数组的索引。这使得查找、插入和删除操作的时间复杂度可以达到 O(1)。然而，哈希表的一个主要问题是碰撞，即当两个键的哈希值相同时，需要一种方法来处理这种情况。<br>字典树，又称前缀树，是一种特殊的树形数据结构，用于存储一种特殊类型的信息，通常是字符串。每个节点表示一个字符串（或者字符串的一部分），从根节点到任何节点的路径都可以表示一个字符串。字典树的主要优点是查找效率高，特别是对于查找前缀或者进行自动补全等操作。但是，它可能需要更多的空间来存储数据。<br>在 CS50 的 Speller 问题集中，我们推荐使用哈希表，因为它在处理大量数据时通常更加高效。</p>
</blockquote>
<p>哈希表如何运行？我去写一个先，见 Note 哈希表</p>
<p>偷偷看了 walkthrough，给出了比 fseek 更好的方案：<br />将字典内的值赋给哈希表，可以使用 string 库的 strcpy 函数<br /><code>strcpy(n-&gt;word,&quot;hello&quot;);</code><br />使用 hash 函数获得每个字符串的哈希值<br /><code>fscanf(file, &quot;%s&quot;,word); //return EOF if reaches file&#39;s end</code><br />设置一个循环：当返回值不为 EOF 时，新建节点，计算哈希值，设置哈希表；读至文件最后一行返回 true<br />设置哈希表有两种方法，头插法和尾插法<br />尾插毕竟简单,<code>table[index]-&gt;next = n;</code> 这句的作用是将新节点添加到链表的尾部。它首先找到当前链表的最后一个节点（<code>table[index]</code>），然后将这个节点的 next 指针指向新节点。这就完成了在链表尾部添加新节点的操作。<br />头插法稍微有点复杂，将表头赋给 new_node-&gt;next，相当于把前一个节点的指针塞到新节点的 next 里，再把新节点赋值给头指针。</p>
<blockquote>
<p>这两种方法的主要区别在于新节点添加的位置不同，一个是添加到链表头部，一个是添加到链表尾部。在哈希表中，通常使用头插法，即将新节点添加到链表头部，因为这种方法的操作更简单，时间复杂度为 O(1)。而尾插法需要遍历整个链表，时间复杂度为 O(n)，在链表较长时效率较低。</p>
</blockquote>
<p><strong>hash()</strong><br />CS50 给了一个哈希函数：以首字母的值设置索引；计算每个 word 的 ASCII 值之和；根据单词长度设置索引<br />总之，尽量避免冲突！并且让哈希值在 buckets 里均匀分布</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Hashes word to a number</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *word)</span><br>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Improve this hash function</span><br>    <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; word[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)<br>    &#123;<br>        length++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> length;<br>    <span class="hljs-comment">//return toupper(word[0]) - &#x27;A&#x27;;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意修改哈希函数会导致所需 buckets 变化，需同步修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Choose number of buckets in hash table</span><br><span class="hljs-comment">//i changed N from 26 to 46 by the longest single word</span><br><span class="hljs-comment">//unsigned int 定义非负数</span><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> N = <span class="hljs-number">46</span>;<br></code></pre></td></tr></table></figure>

<p>也可以直接这样：<code>return strlen(word);</code><br /><strong>size()</strong><br />计算有多少个词，完全不知道怎么写。。。看看 walkthrough，才 26 秒！？<br />load 时记数啊<br />问问鸭子…哦，原来可以在几个函数体外增加全局变量，那就简单了，定义一个 count &#x3D; 0，在 load 循环里加一句 count++,在 size 里如果 load 为真直接返回 count。</p>
<p><strong>check()</strong><br />检验词汇是否存在于字典中<br />首先调用哈希函数查找该词，然后直接用 strcasecmp 函数检验（忽略大小写, 另：该函数位于&lt;string**s**.h&gt;中， 而非&lt;string.h&gt;）<br />实操：获取哈希值 length，ptr 指针直接进入第 length 个桶遍历哈希表，循环条件：该链非空; 判断：词相同，返回真，不同，将 cursor 下一个指针（next）赋值给 cursor；cursor 为空时退出循环，返回 false，表示无该词。</p>
<p><strong>unload()</strong><br />释放所有内存。<br />不能直接 free(table)会造成表头下的链全部泄漏<br />再用一个 cursor 遍历，temp 循环释放内存<br />注意返回 true 的时机，须所有内存均释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, node *cursor = table[i]; cursor != <span class="hljs-literal">NULL</span>; i++)<br>&#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者递归<br />使用 valgrind 检测内存泄漏</p>
<h3 id="SourceCode-1"><a href="#SourceCode-1" class="headerlink" title="SourceCode"></a>SourceCode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Implements a dictionary&#x27;s functionality</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dictionary.h&quot;</span></span><br><br><span class="hljs-comment">// Represents a node in a hash table</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> word[LENGTH + <span class="hljs-number">1</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Choose number of buckets in hash table</span><br><span class="hljs-comment">//i changed N from 26 to 46 by the longest single word</span><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> N = <span class="hljs-number">46</span>;<br><br><span class="hljs-comment">//size计数器</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Hash table</span><br>node *table[N];<br><br><span class="hljs-comment">// Returns true if word is in dictionary, else false</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *word)</span><br>&#123;<br>    <span class="hljs-comment">// TODO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index = hash(word);<br>    node *cursor = table[index];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    for (int i = 0; table[i] != NULL; i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">while</span> (cursor != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (strcasecmp(cursor-&gt;word, word) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cursor = cursor-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// Hashes word to a number</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *word)</span><br>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Improve this hash function</span><br>    <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; word[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)<br>    &#123;<br>        length++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> length;<br>    <span class="hljs-comment">//return toupper(word[0]) - &#x27;A&#x27;;</span><br>&#125;<br><br><span class="hljs-comment">// Loads dictionary into memory, returning true if successful, else false</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *dictionary)</span><br>&#123;<br>    <span class="hljs-comment">// TODO</span><br>    FILE *source = fopen(dictionary,<span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (source == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//要递归调用吗，26个手字符，然后接连表，因为每个node都有一个链表</span><br>    <span class="hljs-comment">//strcpy(n-&gt;word,&quot;hello&quot;) 将字符复制进word</span><br>    <span class="hljs-comment">//读一行创一节点存一词-fscanf（file,&quot;%s&quot;,word） repeat untill EOF returned</span><br>    <span class="hljs-comment">//hash() return a vlaue 确定index，插入</span><br>    <span class="hljs-type">char</span> word[LENGTH + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(source, <span class="hljs-string">&quot;%s&quot;</span>, word) != EOF)<br>    &#123;<br>        node *n = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">strcpy</span>(n-&gt;word,word);<br>        n-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index = hash(word);<br>        n-&gt;next = table[index];<br>        table[index] = n;<br>        count++;<br>    &#125;<br>    <span class="hljs-comment">//记得关闭文件</span><br>    fclose(source);<br>    <span class="hljs-comment">//false改成true</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Returns number of words in dictionary if loaded, else 0 if not yet loaded</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// TODO</span><br>    <span class="hljs-comment">//迭代的方法记数</span><br>    <span class="hljs-keyword">return</span> count;<br>    <span class="hljs-comment">//return 0;</span><br>&#125;<br><br><span class="hljs-comment">// Unloads dictionary from memory, returning true if successful, else false</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">unload</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// TODO</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        node *cursor = table[i];<br>        node *tmp = cursor;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; cursor != <span class="hljs-literal">NULL</span>; j++)<br>        &#123;<br>            cursor = cursor-&gt;next;<br>            <span class="hljs-built_in">free</span>(tmp);<br>            tmp = cursor;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((cursor == <span class="hljs-literal">NULL</span>) &amp;&amp; (i == N - <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/03/09/CS106-lec0-3/">← Next CS106-lec0~3</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/03/09/CS50-Week4/">CS50-Week4 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Qs Wang</a></h1><div id="description"><p>Me,a fresher in NAU,run the blog.</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/wqs111"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="mailto:wqs820626@gmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/107678025"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Notes"><span class="toc-number">1.</span> <span class="toc-text">Notes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.1.</span> <span class="toc-text">链表与内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E4%BA%8C%E5%88%86"><span class="toc-number">1.2.</span> <span class="toc-text">树状二分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">1.3.</span> <span class="toc-text">哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">Trie-前缀树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Psets"><span class="toc-number">2.</span> <span class="toc-text">Psets</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Inheritance"><span class="toc-number">2.1.</span> <span class="toc-text">Inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Before-coding"><span class="toc-number">2.1.1.</span> <span class="toc-text">Before coding</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%EF%BC%9A%E5%AE%B6%E6%97%8F%E8%A1%80%E5%9E%8B%E9%81%97%E4%BC%A0%E6%8E%A8%E6%B5%8B"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">目标：家族血型遗传推测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">细节：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vocabulary"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">Vocabulary</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Understanding"><span class="toc-number">2.1.2.</span> <span class="toc-text">Understanding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Walkthrough"><span class="toc-number">2.1.3.</span> <span class="toc-text">Walkthrough</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SourceCode"><span class="toc-number">2.1.4.</span> <span class="toc-text">SourceCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Speller"><span class="toc-number">2.2.</span> <span class="toc-text">Speller</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Before-coding-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">Before coding</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%EF%BC%9A%E6%9C%80%E5%BF%AB%E7%9A%84%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%99%A8%EF%BC%81"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">目标：最快的拼写检查器！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Background"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">Background</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vocabulary-1"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">Vocabulary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Understanding-1"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">Understanding</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dictionary-h"><span class="toc-number">2.2.1.4.1.</span> <span class="toc-text">dictionary.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dictionary-c"><span class="toc-number">2.2.1.4.2.</span> <span class="toc-text">dictionary.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#speller-c"><span class="toc-number">2.2.1.4.3.</span> <span class="toc-text">speller.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#text"><span class="toc-number">2.2.1.4.4.</span> <span class="toc-text">text&#x2F;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Specification"><span class="toc-number">2.2.2.</span> <span class="toc-text">Specification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Walkthrough-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">Walkthrough</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SourceCode-1"><span class="toc-number">2.2.4.</span> <span class="toc-text">SourceCode</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">copyright</span><a class="icp-content" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a></nobr><br><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/lib/encrypt/hbe.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>